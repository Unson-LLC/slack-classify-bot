const { App, AwsLambdaReceiver } = require('@slack/bolt');
const { classifyMessage } = require('./n8n-integration');
const AirtableIntegration = require('./airtable-integration');

// Initialize Airtable integration
const airtableIntegration = new AirtableIntegration(process.env.N8N_AIRTABLE_ENDPOINT);

// Store file data temporarily (in production, use Redis or DynamoDB)
const fileDataStore = new Map();
// Track processed files to prevent duplicates
const processedFiles = new Set();

// Clean up old data every 30 minutes to prevent memory leaks
setInterval(() => {
  const now = Date.now();
  const thirtyMinutesAgo = now - (30 * 60 * 1000);
  
  // Clean up old file data
  for (const [key, data] of fileDataStore.entries()) {
    if (data.timestamp && data.timestamp < thirtyMinutesAgo) {
      fileDataStore.delete(key);
    }
  }
  
  // Clean up old processed file IDs (keep only last 1000)
  if (processedFiles.size > 1000) {
    const entries = Array.from(processedFiles);
    const toKeep = entries.slice(-500); // Keep last 500
    processedFiles.clear();
    toKeep.forEach(id => processedFiles.add(id));
  }
  
  console.log(`Cleanup completed. FileDataStore: ${fileDataStore.size}, ProcessedFiles: ${processedFiles.size}`);
}, 30 * 60 * 1000); // 30 minutes

// Initialize AWS Lambda receiver
const awsLambdaReceiver = new AwsLambdaReceiver({
  signingSecret: process.env.SLACK_SIGNING_SECRET,
});

// Initialize Slack app with Lambda receiver
const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  receiver: awsLambdaReceiver,
});

// Message classification handler
app.message(async ({ message, client, logger }) => {
  try {
    // Skip bot messages and messages without text
    if (message.subtype === 'bot_message' || !message.text) {
      return;
    }

    logger.info('Processing message for classification:', message.text);

    // Classify the message using n8n
    const classification = await classifyMessage(message.text);
    
    if (classification && classification.category) {
      // React to the message with an emoji based on classification
      const emojiMap = {
        'bug': 'bug',
        'feature-request': 'bulb',
        'question': 'question',
        'feedback': 'speech_balloon',
        'urgent': 'rotating_light',
        'general': 'speech_balloon'
      };
      
      const emoji = emojiMap[classification.category] || 'speech_balloon';
      
      await client.reactions.add({
        channel: message.channel,
        timestamp: message.ts,
        name: emoji
      });

      // Post classification result in thread
      await client.chat.postMessage({
        channel: message.channel,
        thread_ts: message.ts,
        text: `ü§ñ Message classified as: *${classification.category}*\nConfidence: ${classification.confidence || 'N/A'}`
      });
    }
  } catch (error) {
    logger.error('Error in message classification:', error);
  }
});

// File upload handler with project selection
app.event('file_shared', async ({ event, client, logger }) => {
  try {
    logger.info('File shared event received:', event);

    // Create unique identifier for this file event
    const eventId = `${event.file_id}_${event.ts}`;
    
    // Check if we've already processed this file event
    if (processedFiles.has(eventId)) {
      logger.info('File event already processed, skipping:', eventId);
      return;
    }
    
    // Mark as processing
    processedFiles.add(eventId);

    // Get file info
    const fileInfo = await client.files.info({
      file: event.file_id
    });

    const file = fileInfo.file;
    
    // Only process .txt files
    if (file.filetype === 'txt' || file.name.endsWith('.txt')) {
      logger.info('Processing .txt file:', file.name);
      
      // Download file content
      const response = await fetch(file.url_private, {
        headers: {
          'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`
        }
      });
      
      const content = await response.text();
      
      // Store file data temporarily
      const fileKey = `${event.file_id}_${Date.now()}`;
      fileDataStore.set(fileKey, {
        fileName: file.name,
        content: content,
        uploadedBy: event.user_id,
        channel: event.channel_id,
        ts: event.ts,
        fileId: event.file_id,
        timestamp: Date.now()
      });

      // Get projects from Airtable
      const projects = await airtableIntegration.getProjects();
      
      if (projects.length === 0) {
        await client.chat.postMessage({
          channel: event.channel_id,
          text: `‚ùå „Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇAirtable„Å´„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊÉÖÂ†±„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`
        });
        return;
      }

      // Create interactive message with project selection buttons
      const blocks = airtableIntegration.createProjectSelectionBlocks(projects, fileKey);
      
      await client.chat.postMessage({
        channel: event.channel_id,
        text: `üìÅ „Éï„Ç°„Ç§„É´ "${file.name}" „Åå„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åï„Çå„Åæ„Åó„Åü„ÄÇ`,
        blocks: blocks,
        thread_ts: event.ts
      });

    } else {
      logger.info('Skipping non-txt file:', file.name);
    }
  } catch (error) {
    logger.error('Error in file processing:', error);
    
    // Remove from processed set on error so it can be retried
    const eventId = `${event.file_id}_${event.ts}`;
    processedFiles.delete(eventId);
    
    try {
      await client.chat.postMessage({
        channel: event.channel_id,
        text: `‚ùå „Éï„Ç°„Ç§„É´Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error.message}`
      });
    } catch (replyError) {
      logger.error('Error sending error message:', replyError);
    }
  }
});

// Handle project selection button clicks
app.action(/^select_project_/, async ({ ack, body, client, action, logger }) => {
  await ack();

  try {
    const actionValue = JSON.parse(action.value);
    const { projectId, projectName, fileId } = actionValue;
    
    // Get stored file data
    const fileData = fileDataStore.get(fileId);
    if (!fileData) {
      await client.chat.update({
        channel: body.channel.id,
        ts: body.message.ts,
        text: `‚ùå „Éï„Ç°„Ç§„É´„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇÂÜçÂ∫¶„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`,
        blocks: []
      });
      return;
    }

    // Update message to show processing
    await client.chat.update({
      channel: body.channel.id,
      ts: body.message.ts,
      text: `üîÑ „Éó„É≠„Ç∏„Çß„ÇØ„Éà "${projectName}" „Åß„Éï„Ç°„Ç§„É´ "${fileData.fileName}" „ÇíÂá¶ÁêÜ‰∏≠...`,
      blocks: []
    });

    // Process file with selected project
    const result = await airtableIntegration.processFileWithProject({
      fileContent: fileData.content,
      fileName: fileData.fileName,
      projectId: projectId,
      userId: fileData.uploadedBy,
      channelId: fileData.channel,
      ts: fileData.ts
    });

    // Clean up stored data
    fileDataStore.delete(fileId);

    if (result.success) {
      await client.chat.update({
        channel: body.channel.id,
        ts: body.message.ts,
        text: `‚úÖ „Éï„Ç°„Ç§„É´ "${fileData.fileName}" „Åå„Éó„É≠„Ç∏„Çß„ÇØ„Éà "${projectName}" „ÅßÊ≠£Â∏∏„Å´Âá¶ÁêÜ„Åï„Çå„Åæ„Åó„ÅüÔºÅ\n\nüìä **„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊÉÖÂ†±:**\n‚Ä¢ Owner: ${result.project.owner}\n‚Ä¢ Repo: ${result.project.repo}\n‚Ä¢ Path: ${result.project.path_prefix}\n‚Ä¢ Branch: ${result.project.branch || 'main'}`,
        blocks: []
      });
    } else {
      await client.chat.update({
        channel: body.channel.id,
        ts: body.message.ts,
        text: `‚ùå „Éï„Ç°„Ç§„É´Âá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${result.error}`,
        blocks: []
      });
    }

  } catch (error) {
    logger.error('Error handling project selection:', error);
    
    try {
      await client.chat.update({
        channel: body.channel.id,
        ts: body.message.ts,
        text: `‚ùå „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈÅ∏Êäû„ÅÆÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error.message}`,
        blocks: []
      });
    } catch (updateError) {
      logger.error('Error updating message:', updateError);
    }
  }
});

// Handle cancel button click
app.action('cancel_project_selection', async ({ ack, body, client, action, logger }) => {
  await ack();

  try {
    const actionValue = JSON.parse(action.value);
    const { fileId } = actionValue;
    
    // Clean up stored data
    fileDataStore.delete(fileId);

    await client.chat.update({
      channel: body.channel.id,
      ts: body.message.ts,
      text: `‚ùå „Éï„Ç°„Ç§„É´Âá¶ÁêÜ„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü„ÄÇ`,
      blocks: []
    });

  } catch (error) {
    logger.error('Error handling cancel action:', error);
  }
});

// Slash command: /classify
app.command('/classify', async ({ ack, body, client }) => {
  await ack();

  try {
    const text = body.text;
    
    if (!text) {
      await client.chat.postEphemeral({
        channel: body.channel_id,
        user: body.user_id,
        text: "Please provide text to classify. Usage: `/classify your message here`"
      });
      return;
    }

    // Show loading message
    await client.chat.postEphemeral({
      channel: body.channel_id,
      user: body.user_id,
      text: "ü§ñ Classifying your message..."
    });

    // Classify the message
    const classification = await classifyMessage(text);
    
    if (classification && classification.category) {
      await client.chat.postMessage({
        channel: body.channel_id,
        text: `ü§ñ Classification result for: "${text}"\n\n*Category:* ${classification.category}\n*Confidence:* ${classification.confidence || 'N/A'}\n*Requested by:* <@${body.user_id}>`
      });
    } else {
      await client.chat.postEphemeral({
        channel: body.channel_id,
        user: body.user_id,
        text: "‚ùå Failed to classify the message. Please try again."
      });
    }
  } catch (error) {
    console.error('Error in /classify command:', error);
    await client.chat.postEphemeral({
      channel: body.channel_id,
      user: body.user_id,
      text: "‚ùå An error occurred while classifying the message."
    });
  }
});

// Slash command: /process-file
app.command('/process-file', async ({ ack, body, client }) => {
  await ack();

  try {
    await client.chat.postEphemeral({
      channel: body.channel_id,
      user: body.user_id,
      text: "üìÅ **„Éï„Ç°„Ç§„É´Âá¶ÁêÜ„Å´„Å§„ÅÑ„Å¶**\n\n**Ëá™ÂãïÂá¶ÁêÜ:**\n1. .txt„Éï„Ç°„Ç§„É´„Çí„ÉÅ„É£„É≥„Éç„É´„Å´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ\n2. „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈÅ∏Êäû„Éú„Çø„É≥„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô\n3. ÈÅ©Âàá„Å™„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíÈÅ∏Êäû\n4. Ëá™ÂãïÁöÑ„Å´Airtable„Å®GitHub„Å´‰øùÂ≠ò„Åï„Çå„Åæ„Åô\n\n**ÂØæÂøú„Éï„Ç°„Ç§„É´ÂΩ¢Âºè:** .txt\n**Âà©Áî®ÂèØËÉΩ„Éó„É≠„Ç∏„Çß„ÇØ„Éà:** Airtable„ÅßÁÆ°ÁêÜ„Åï„Çå„Å¶„ÅÑ„Çã„Éó„É≠„Ç∏„Çß„ÇØ„Éà‰∏ÄË¶ß„Åã„ÇâÈÅ∏Êäû"
    });
  } catch (error) {
    console.error('Error in /process-file command:', error);
  }
});

// Slash command: /hello-bolt-app
app.command('/hello-bolt-app', async ({ ack, body, client }) => {
  await ack();

  try {
    const result = await client.chat.postMessage({
      channel: body.channel_id,
      text: `Hello <@${body.user_id}>! üëã\n\n**Slack Classify Bot** (AWS LambdaÁâà) üöÄ\n\n**üìã Âà©Áî®ÂèØËÉΩ„Å™Ê©üËÉΩ:**\n\n**ü§ñ Ëá™Âãï„É°„ÉÉ„Çª„Éº„Ç∏ÂàÜÈ°û**\n‚Ä¢ „ÉÅ„É£„É≥„Éç„É´„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíËá™ÂãïÂàÜÈ°û\n‚Ä¢ ÂàÜÈ°ûÁµêÊûú„Å´Âøú„Åò„ÅüÁµµÊñáÂ≠ó„É™„Ç¢„ÇØ„Ç∑„Éß„É≥\n‚Ä¢ „Çπ„É¨„ÉÉ„Éâ„ÅßÂàÜÈ°ûÁµêÊûú„ÇíÈÄöÁü•\n\n**üìÅ „Éï„Ç°„Ç§„É´Âá¶ÁêÜ („Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈÅ∏ÊäûÂºè)**\n‚Ä¢ .txt„Éï„Ç°„Ç§„É´„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÇíÊ§úÂá∫\n‚Ä¢ Airtable„Åã„Çâ„Éó„É≠„Ç∏„Çß„ÇØ„Éà‰∏ÄË¶ß„ÇíÂèñÂæó\n‚Ä¢ „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Éú„Çø„É≥„Åß„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈÅ∏Êäû\n‚Ä¢ ÈÅ∏Êäû„Åï„Çå„Åü„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆGitHub„É™„Éù„Ç∏„Éà„É™„Å´Ëá™Âãï‰øùÂ≠ò\n\n**‚ö° „Çπ„É©„ÉÉ„Ç∑„É•„Ç≥„Éû„É≥„Éâ:**\n‚Ä¢ \`/classify <message>\` - ÊåáÂÆö„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂàÜÈ°û\n‚Ä¢ \`/process-file\` - „Éï„Ç°„Ç§„É´Âá¶ÁêÜ„ÅÆË©≥Á¥∞Ë™¨Êòé\n‚Ä¢ \`/hello-bolt-app\` - „Åì„ÅÆ„Éò„É´„Éó„É°„ÉÉ„Çª„Éº„Ç∏\n\n**üîß ÊäÄË°ì„Çπ„Çø„ÉÉ„ÇØ:**\n‚Ä¢ AWS Lambda + Slack Bolt\n‚Ä¢ Airtable („Éó„É≠„Ç∏„Çß„ÇØ„ÉàÁÆ°ÁêÜ)\n‚Ä¢ n8n („ÉØ„Éº„ÇØ„Éï„É≠„ÉºËá™ÂãïÂåñ)\n‚Ä¢ GitHub („Éï„Ç°„Ç§„É´‰øùÂ≠ò)`
    });
    console.log(result);
  } catch (error) {
    console.error('Error in /hello-bolt-app command:', error);
  }
});

// Error handler
app.error(async (error) => {
  console.error('App error:', error);
});

// Lambda handler
exports.handler = async (event, context, callback) => {
  console.log('Lambda function started');
  console.log('Event:', JSON.stringify(event, null, 2));
  
  try {
    // Handle Slack URL verification challenge (for initial setup)
    if (event.body) {
      let body;
      try {
        body = typeof event.body === 'string' ? JSON.parse(event.body) : event.body;
        
        // Handle Slack URL verification challenge
        if (body.type === 'url_verification') {
          console.log('URL verification challenge detected');
          return {
            statusCode: 200,
            headers: {
              'Content-Type': 'text/plain'
            },
            body: body.challenge
          };
        }
      } catch (parseError) {
        console.error('Error parsing body for challenge check:', parseError);
      }
    }
    
    // Handle normal Slack events through Bolt
    const handler = await awsLambdaReceiver.start();
    return handler(event, context, callback);
    
  } catch (error) {
    console.error('Error in Lambda handler:', error);
    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        error: 'Internal server error',
        message: error.message,
        timestamp: new Date().toISOString()
      })
    };
  }
}; 